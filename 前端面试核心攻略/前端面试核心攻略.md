## 闭包

#### 理解作用域

`var name = 'hahaha'`

- var name -- 编译时处理

  > 编译阶段： 这时登场的是一个叫 **编译器** 的家伙。编译器会找遍当前作用域，看看是不是已经有一个叫 name 的家伙了。如果有，那么就忽略 var name 这个声明，继续编译下去；如果没有，则在当前作用域里新增一个 name。然后，编译器会为引擎生成运行时所需要的代码，程序就进入了执行阶段

- name = 'hahaha' -- 运行时处理

  > 执行阶段： 这时登场的就是 **JS 引擎** 了。JS 引擎在执行代码的时候，仍然会找遍当前作用域，看看是不是有一个叫 name 的家伙。如果能找到，那么万事大吉，我来给你赋值。如果找不到，它也不会灰心，它会从当前作用域里 “探出头去”，看看 “外面” 有没有，或者 “外面的外面” 有没有。如果最终仍然找不到 name 变量，引擎就会抛出一个异常

#### 作用域链

- 全局作用域
- 函数作用域（局部作用域）
- 块作用域（局部作用域）

```javascript
function add(a){
	console.log(a+b)
  console.log(c) // 报错
}

var b = 1

add(2) // 3
```

![作用域](./area.png)

在函数add里访问变量b，发现找不到，于是js引擎去上层作用域找到了b，拿来使用；没找到c并且全局之外没有别的作用域，于是报错。

```javascript
function addABC(){
  var a = 1,b = 2;
  
  function add(){
    return a+b+c;
  }
  return add;
}

var c = 3

var globalAdd = addABC()

console.log(globalAdd()) // 6
```

![](./area-linker.png)

对于函数add，它嵌套在addABC内部，用到变量a,b,c时，需要去上层作用域中获取。

像a,b,c这种在函数中被使用，但它既不是函数参数也不是函数的局部变量，而是一个不属于当前作用域的变量，此时它相对于当前作用域来说是一个自由变量；而像add这样引用了自由变量的函数，被称作闭包。

#### 词法作用域和动态作用域

**JS 的作用域遵循的就是词法作用域模型**

词法作用域模型是指在书写的过程中，根据书写的位置来决定划分作用域的方式。

动态作用域模型则会遵循沿着函数调用栈的方式来寻求变量的方式。

因此，词法作用域和动态作用域的区别主要在作用域划分的时机：

- 词法作用域在代码定义的时候完成划分，作用域链沿着定义的位置向外延伸
- 动态作用域在代码运行的时候完成划分，作用域链沿着调用栈向外延伸

#### 循环体和闭包系列真题

------

```javascript
for(var i = 0; i < 5; i++) {
	setTimeout(function() {
    console.log(i);
  }, 1000);
}

console.log(i);
// 5 0 1 2 3 4
```

正确输出：`5 5 5 5 5`

因为setTimeout函数将for循环中的打印操作延后了，因此for循环外的console会最先被执行，打印出第一个5；一秒后，setTimeout中的函数开始执行，因为function中没有定义自己的变量，因此会根据闭包的作用域链去全局中取变量i，此时i的值以及变成5了，这样的操作循环了四次，因此又打印了四个5。

![1](./answer1.png)

要想打印出`5 0 1 2 3 4`的结果，我们可以通过下面三个方法去改造上述函数：

1. 将每一轮循环里i的值，传入setTimeout函数

   ```javascript
   for(var i = 0; i < 5; i++) {
   	setTimeout(function() {
       console.log(i);
     }, 1000, i);
   }
   
   console.log(i);
   ```

2. 在setTimeout函数外嵌套函数，缓存并通过入参来告诉每个循环i的值

   ```javascript
   var output = function (i) {
       setTimeout(function() {
           console.log(i);
       }, 1000);
   };
   
   for (var i = 0; i < 5; i++) {
       // 这里的 i 被赋值给了 output 作用域内的变量 i
       output(i);  
   }
   
   console.log(i);
   ```

3. 同样是在 setTimeout 外面再套一层函数，只不过这个函数是一个**立即执行函数**。

   ```javascript
   for (var i = 0; i < 5; i++) {
       // 这里的 i 被赋值给了立即执行函数作用域内的变量 j
       (function(j) {  
           setTimeout(function() {
               console.log(j);
           }, 1000);
       })(i);
   }
   ```

------

```javascript
function test (){
    var num = []
    var i

    for (i = 0; i < 10; i++) {
        num[i] = function () {
            console.log(i)
        }
    }

    return num[9]
}

test()()
// output: 10 对于num数组来说，0-9每一项都是一个函数，他们的函数内部都没有定义属于自己的变量，因此打印函数被调用的时候会去访问获取全局作用域中的i的值，因此num的每一项打印出来的数据都是全局i的值10
```

------

```javascript
var test = (function() {
    var num = 0
    return () => {
        return num++
    }
}())

for (var i = 0; i < 10; i++) {
    test()
}

console.log(test())
// output: 10 test是一个立即执行函数，封装了变量num，箭头函数为闭包，没定义变量，因此每次函数被调用都是去修改test函数中的num的值，for循环结束后，num的值是9，console语句再次调用test函数，return的值为9++ -> 10
```

------

```javascript
var a = 1;
function test(){
    a = 2; // 声明var被提前 var a=2
    return function(){
        console.log(a);
    }
    var a = 3; // 变量提升
}
test()();
// 2
```

![2](./answer2.png)

------

```javascript
function foo(a,b){
  console.log(b);
  return {
    foo:function(c){
      return foo(c,a);
    }
  }
}
 
var func1=foo(0);
func1.foo(1);
func1.foo(2);
func1.foo(3);
var func2=foo(0).foo(1).foo(2).foo(3);
var func3=foo(0).foo(1);
func3.foo(2);
func3.foo(3);
```

## js内存管理机制

#### js内存生命周期

js语言向用户隐藏了内存管理的相关方法，自己默默完成了所有的管理动作。

js的内存生命周期分为三个阶段：分配内存-内存读写-内存释放

js中的数据类型分为基本类型和引用类型；基本类型包括string,number,boolean…他们的特征是大小固定、体积轻量、相对简单，被放在js的栈内存中；引用类型包括object,array,function等，他们比较复杂、占用空间大、大小不定，他们被放在js的堆内存中。

访问基本数据类型的变量时，从栈中直接获取该变量的值；而访问引用类型的变量，需要先从栈中获取变量对应对象的引用（即它在堆内存中的地址），然后用获取到的地址去堆内存查询才能拿到数据内容。

#### 垃圾回收机制

1. 引用计数法（弃用）

   每当一个变量指向一个值，就创建了一次这个值得引用，一段时间后，js会对所有值进行巡检，引用标记为0的值内存会被清除。

   但引用计数法无法甄别循环引用场景下的垃圾，长此以往就会造成内存泄漏。

2. 标记清除法

   一个变量被机制判断是否清除的标准是它是否可抵达。

## this指向原则

多数情况下，this指向调用方法的对象。

```javascript
// 声明位置
var me = {
  name: 'xiuyan',
  hello: function() {
    console.log(`你好，我是${this.name}`)
  }
}

var you = {
  name: 'xiaoming',
  hello: me.hello
}

// 调用位置
me.hello() // xiuyan
you.hello() // xiaoming
```

```javascript
// 声明位置
var me = {
  name: 'xiuyan',
  hello: function() {
    console.log(`你好，我是${this.name}`)
  }
}

var name = 'BigBear'
var hello = me.hello

// 调用位置
me.hello() // xiuyan
hello() // BigBear
```

```javascript
// 声明位置
var me = {
  name: 'xiuyan',
  hello: function() {
    console.log(`你好，我是${this.name}`)
  }
}

var you = {
  name: 'xiaoming',
  hello: function() {
    var targetFunc = me.hello
    targetFunc()
  }
}

var name = 'BigBear'

// 调用位置
you.hello() // BigBear

// targetFunc虽然声明在you函数中，但在调用时，并未给任何对象的前缀，因此此时的targetFun是挂在在全局作用域的，you对象的this并没有被传递给函数
```

**不管方法被书写在哪个位置，它的 this 只会跟着它的调用方走**

#### 特殊情景下的this

在三种特殊情况下，this指向window：

1. 立即执行函数
2. setTimeout中传入的函数
3. setInterval传入的函数

```javascript
var name = 'BigBear'

var me = {
  name: 'xiuyan',
  // 声明位置
  sayHello: function() {
    console.log(`你好，我是${this.name}`)
  },
  hello: function() {
    (function(cb) {
      // 调用位置
      cb()
    })(this.sayHello)
  }
}

me.hello() // BigBear
```

#### 箭头函数

箭头函数中的this只认“词法作用域”，因此箭头函数中this的指向和调用方式无关，由书写的位置决定。

```javascript
var name = 'BigBear'
var me = {
  name: 'xiuyan',
  // 声明位置
  hello: () => {
      console.log(this.name)
  }
}

// 调用位置
me.hello() // BigBear
```

练习

```javascript
var a = 1
var obj = {
  a: 2,
  func2: () => {
    console.log(this.a)
  },
  
  func3: function() {
    console.log(this.a)
  }
}

// func1
var func1  = () => {
  console.log(this.a)
}

// func2
var func2 = obj.func2
// func3
var func3 = obj.func3

func1() // 1
func2() // 1
func3() // 1
obj.func2() // 1
obj.func3() // 2
```

#### 改变this指向的方式

##### - 改变书写代码的方式

箭头函数（根据声明位置决定this的指向）

```javascript
var a = 1

var obj = {
  a: 2,
  // 声明位置
  showA: () => {
      console.log(this.a)
  }
}

// 调用位置
obj.showA() // 1
```

构造函数（构造函数里的this会绑定到new出来的对象上）

```javascript
function Person(name) {
  this.name = name
  console.log(this)
}

var person = new Person('xiuyan')
Person{ name : "xiuyan" }
```

##### - 显示调用方法帮忙

call、apply和bind的作用和区别？

![difference](./changeTHIS.png)

```javascript
var me = {
  name: 'xiuyan'
}

function showName() {
  console.log(this.name)
}

showName.call(me) // xiuyan
```

- call是可以被所有函数继承的，应该定义在Function.prototype上
- call方法先改变了this的指向，将this绑定到第一个参数指定的对象上；再根据输入的参数执行函数

## 执行上下文与调用栈

- 为什么要有执行上下文

  分治是代码书写过程中很重要的一个思想，即细分文件、模块、方法的书写方式。

  我们可以把执行上下文理解为引擎在执行过程中对代码进行了又一次划分，从而降低复杂度。

- 执行上下文的分类

  1.全局上下文

  2.函数上下文

- 上下文的生命周期

  1.创建阶段 - 初始阶段，代码未执行，只是做了准备工作

  2.执行阶段 - 逐行执行脚本中的代码
  
- 调用栈

  在js代码执行过程中，引擎会创建执行上下文栈，也叫调用栈，函数上下文的创建和销毁过程，对应着入栈和出栈的操作。

## 原型编程范式与面向对象

在JavaScript中，每个构造函数都有一个prototype属性，它指向构造函数的原型对象，这个原型对象中有一个construtor属性指回构造函数；每个实例有一个\_proto\_属性，当我们使用构造函数去创建实例时，实例的\_proto\_属性就会指向构造函数的原型对象。

```javascript
// 创建一个Dog构造函数
function Dog(name, age) {
  this.name = name
  this.age = age
}
Dog.prototype.eat = function() {
  console.log('肉骨头真好吃')
}
// 使用Dog构造函数创建dog实例
const dog = new Dog('旺财', 3)

// someFunc.__proto__ === Function.prototype;
// Function.prototype.__proto__ === Object.prototype;
```

![](./prototype.jpg)

#### 真题

```javascript
var A = function() {};
A.prototype.n = 1;
var b = new A();
A.prototype = {
  n: 2,
  m: 3
}
var c = new A();

console.log(b.n);
console.log(b.m);

console.log(c.n);
console.log(c.m);

// 1
// undefined
// 2
// 3
```

b和A的原型关系：

![](./bArelation.jpeg)

c和A的原型关系：

![](./cArelation.jpeg)

**为什么b和c继承自同一个原型对象，却有不同的表现呢？**

new一个实例对象的时候发生了什么事：为新对象开辟一块新的内存  => 把函数体内的this指向开辟的内存空间 => 将新对象的\_proto_属性指向对对应构造函数的prototype属性，把实例和原型对象关联 => 执行函数体内的逻辑并return新对象

因此，在第二步执行完后，b的原型就把A的prototype的引用储存下来了。

而在修改A的prototype时，只是重新赋值，使得A的prototype指向一个全新的对象。

![](./Arevalue.jpeg)

因此b指向旧的引用，c指向新的引用，最终造成了不一样的输出结果。

------

```javascript
function A() {
    this.name = 'a'
    this.color = ['green', 'yellow']
 }
 function B() {
   
 }
 B.prototype = new A()
 var b1 = new B()
 var b2 = new B()
 
 b1.name = 'change'
 b1.color.push('black')

console.log(b2.name) // 'a'
console.log(b2.color) // ["green", "yellow", "black"]
```

原型链图：

![](./prototypeLink.jpeg)

在写操作的过程中，如果发现name属性在b1上没有，会原地为b1创建新属性而不会沿着原型链向上寻找定位；但对于读操作来说，如果在当前对象的属性中没有发现对应的值，则会顺着原型链逆流而上寻找已经存在的值。

```b1.color.push('black')```这样的写法没有改变对象的引用，而是在原有对象的基础上修改了内容，因此走的是原型链**查询+修改**的操作。

如果想要单纯执行写操作，应该```b1.color=["green", "yellow", "black"]```

------

```javascript
function A() {}
function B(a) {
    this.a = a;
}
function C(a) {
    if (a) {
        this.a = a;
    }
}
A.prototype.a = 1;
B.prototype.a = 1;
C.prototype.a = 1;

console.log(new A().a); // 1
console.log(new B().a); // undefined
console.log(new C().a); // 1
console.log(new C(2).a); // 2
```

原型链图：

![](./ABCprototype.png)

当我们去new对象的实例时，会先开辟空间，this指向空间，将实例的\_prop_属性指向构造函数的prototype，执行函数体并return实例。

对于实例a来说，执行了空函数体后的a中没有找到变量a，因此沿着\_prop_找到A的prototype中的a=1；

对于实例b来说，构造函数会无条件为实例创建一个自有属性a，并将a赋值为入参，入参为undefined，所以a=undefined；

对于实例c，如果入参不为false，则自有属性a的值为入参的值，若传入的值为false，则不会为实例创建自有属性，沿着\_proto_找到原型链中的值输出为a=1