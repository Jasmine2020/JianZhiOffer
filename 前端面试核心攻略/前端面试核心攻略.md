## 闭包

#### 理解作用域

`var name = 'hahaha'`

- var name -- 编译时处理

  > 编译阶段： 这时登场的是一个叫 **编译器** 的家伙。编译器会找遍当前作用域，看看是不是已经有一个叫 name 的家伙了。如果有，那么就忽略 var name 这个声明，继续编译下去；如果没有，则在当前作用域里新增一个 name。然后，编译器会为引擎生成运行时所需要的代码，程序就进入了执行阶段

- name = 'hahaha' -- 运行时处理

  > 执行阶段： 这时登场的就是 **JS 引擎** 了。JS 引擎在执行代码的时候，仍然会找遍当前作用域，看看是不是有一个叫 name 的家伙。如果能找到，那么万事大吉，我来给你赋值。如果找不到，它也不会灰心，它会从当前作用域里 “探出头去”，看看 “外面” 有没有，或者 “外面的外面” 有没有。如果最终仍然找不到 name 变量，引擎就会抛出一个异常

#### 作用域链

- 全局作用域
- 函数作用域（局部作用域）
- 块作用域（局部作用域）

```javascript
function add(a){
	console.log(a+b)
  console.log(c) // 报错
}

var b = 1

add(2) // 3
```

![作用域](./area.png)

在函数add里访问变量b，发现找不到，于是js引擎去上层作用域找到了b，拿来使用；没找到c并且全局之外没有别的作用域，于是报错。

```javascript
function addABC(){
  var a = 1,b = 2;
  
  function add(){
    return a+b+c;
  }
  return add;
}

var c = 3

var globalAdd = addABC()

console.log(globalAdd()) // 6
```

![](./area-linker.png)

对于函数add，它嵌套在addABC内部，用到变量a,b,c时，需要去上层作用域中获取。

像a,b,c这种在函数中被使用，但它既不是函数参数也不是函数的局部变量，而是一个不属于当前作用域的变量，此时它相对于当前作用域来说是一个自由变量；而像add这样引用了自由变量的函数，被称作闭包。

#### 词法作用域和动态作用域

**JS 的作用域遵循的就是词法作用域模型**

词法作用域模型是指在书写的过程中，根据书写的位置来决定划分作用域的方式。

动态作用域模型则会遵循沿着函数调用栈的方式来寻求变量的方式。

因此，词法作用域和动态作用域的区别主要在作用域划分的时机：

- 词法作用域在代码定义的时候完成划分，作用域链沿着定义的位置向外延伸
- 动态作用域在代码运行的时候完成划分，作用域链沿着调用栈向外延伸

#### 循环体和闭包系列真题

------

```javascript
for(var i = 0; i < 5; i++) {
	setTimeout(function() {
    console.log(i);
  }, 1000);
}

console.log(i);
// 5 0 1 2 3 4
```

正确输出：`5 5 5 5 5`

因为setTimeout函数将for循环中的打印操作延后了，因此for循环外的console会最先被执行，打印出第一个5；一秒后，setTimeout中的函数开始执行，因为function中没有定义自己的变量，因此会根据闭包的作用域链去全局中取变量i，此时i的值以及变成5了，这样的操作循环了四次，因此又打印了四个5。

![1](./answer1.png)

要想打印出`5 0 1 2 3 4`的结果，我们可以通过下面三个方法去改造上述函数：

1. 将每一轮循环里i的值，传入setTimeout函数

   ```javascript
   for(var i = 0; i < 5; i++) {
   	setTimeout(function() {
       console.log(i);
     }, 1000, i);
   }
   
   console.log(i);
   ```

2. 在setTimeout函数外嵌套函数，缓存并通过入参来告诉每个循环i的值

   ```javascript
   var output = function (i) {
       setTimeout(function() {
           console.log(i);
       }, 1000);
   };
   
   for (var i = 0; i < 5; i++) {
       // 这里的 i 被赋值给了 output 作用域内的变量 i
       output(i);  
   }
   
   console.log(i);
   ```

3. 同样是在 setTimeout 外面再套一层函数，只不过这个函数是一个**立即执行函数**。

   ```javascript
   for (var i = 0; i < 5; i++) {
       // 这里的 i 被赋值给了立即执行函数作用域内的变量 j
       (function(j) {  
           setTimeout(function() {
               console.log(j);
           }, 1000);
       })(i);
   }
   ```

------

```javascript
function test (){
    var num = []
    var i

    for (i = 0; i < 10; i++) {
        num[i] = function () {
            console.log(i)
        }
    }

    return num[9]
}

test()()
// output: 10 对于num数组来说，0-9每一项都是一个函数，他们的函数内部都没有定义属于自己的变量，因此打印函数被调用的时候会去访问获取全局作用域中的i的值，因此num的每一项打印出来的数据都是全局i的值10
```

------

```javascript
var test = (function() {
    var num = 0
    return () => {
        return num++
    }
}())

for (var i = 0; i < 10; i++) {
    test()
}

console.log(test())
// output: 10 test是一个立即执行函数，封装了变量num，箭头函数为闭包，没定义变量，因此每次函数被调用都是去修改test函数中的num的值，for循环结束后，num的值是9，console语句再次调用test函数，return的值为9++ -> 10
```

------

```javascript
var a = 1;
function test(){
    a = 2; // 声明var被提前 var a=2
    return function(){
        console.log(a);
    }
    var a = 3; // 变量提升
}
test()();
// 2
```

![2](./answer2.png)

------

```javascript
function foo(a,b){
  console.log(b);
  return {
    foo:function(c){
      return foo(c,a);
    }
  }
}
 
var func1=foo(0);
func1.foo(1);
func1.foo(2);
func1.foo(3);
var func2=foo(0).foo(1).foo(2).foo(3);
var func3=foo(0).foo(1);
func3.foo(2);
func3.foo(3);
```

## js内存管理机制

#### js内存生命周期

js语言向用户隐藏了内存管理的相关方法，自己默默完成了所有的管理动作。

js的内存生命周期分为三个阶段：分配内存-内存读写-内存释放

js中的数据类型分为基本类型和引用类型；基本类型包括string,number,boolean…他们的特征是大小固定、体积轻量、相对简单，被放在js的栈内存中；引用类型包括object,array,function等，他们比较复杂、占用空间大、大小不定，他们被放在js的堆内存中。

访问基本数据类型的变量时，从栈中直接获取该变量的值；而访问引用类型的变量，需要先从栈中获取变量对应对象的引用（即它在堆内存中的地址），然后用获取到的地址去堆内存查询才能拿到数据内容。

#### 垃圾回收机制

1. 引用计数法（弃用）

   每当一个变量指向一个值，就创建了一次这个值得引用，一段时间后，js会对所有值进行巡检，引用标记为0的值内存会被清除。

   但引用计数法无法甄别循环引用场景下的垃圾，长此以往就会造成内存泄漏。

2. 标记清除法

   一个变量被机制判断是否清除的标准是它是否可抵达。

## this指向原则

多数情况下，this指向调用方法的对象。

```javascript
// 声明位置
var me = {
  name: 'xiuyan',
  hello: function() {
    console.log(`你好，我是${this.name}`)
  }
}

var you = {
  name: 'xiaoming',
  hello: me.hello
}

// 调用位置
me.hello() // xiuyan
you.hello() // xiaoming
```

```javascript
// 声明位置
var me = {
  name: 'xiuyan',
  hello: function() {
    console.log(`你好，我是${this.name}`)
  }
}

var name = 'BigBear'
var hello = me.hello

// 调用位置
me.hello() // xiuyan
hello() // BigBear
```

```javascript
// 声明位置
var me = {
  name: 'xiuyan',
  hello: function() {
    console.log(`你好，我是${this.name}`)
  }
}

var you = {
  name: 'xiaoming',
  hello: function() {
    var targetFunc = me.hello
    targetFunc()
  }
}

var name = 'BigBear'

// 调用位置
you.hello() // BigBear

// targetFunc虽然声明在you函数中，但在调用时，并未给任何对象的前缀，因此此时的targetFun是挂在在全局作用域的，you对象的this并没有被传递给函数
```

**不管方法被书写在哪个位置，它的 this 只会跟着它的调用方走**

